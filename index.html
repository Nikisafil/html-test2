<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Мой документ</title>
</head>
<body>
    <h1>Нотация описания архитектуры приложения</h1>
    <h2>Мотивация</h2>
    <!-- что угодно -->
    <img src="./images/image1.jpg" alt="Описание картинки" width="500px" />
    <p>
        Я, как технический директор, регулярно сталкиваюсь с необоходимостью обсудить с командой<br>
        архитектуру нового приложения или микросервиса. И в рамках таких обсуждений я понял,<br>
        что не существует единого подхода, который позволил бы эффективно общаться команде,<br>
        обсуждая архитектурные решения.<br>
    </p>
    <p>
        Понятно, что на словах это не обьяснишь и приходится прибегать к дополнительным<br>
        инструментам в виде доски и маркера или же при текущих реалиях - online доски типа <a href="https://miro.com/ru/" target="_blank">Miro</a>.<br>
        Но даже в этом случае обсуждение сваливается в хаотично нарисованные квадратики,круги<br>
        или прямоугольники с текстом, как-то соединённые стрелками.<br>
    </p>
    <p>
        При этом от обсуждения к обсуждению одна и так же схема может быть нарисована 1000<br>
        разным способами. Кто-то в творческом порыве начинает рисовать иконки пользователей<br>
        или серверов, а кто-то рисует поток из 10 стрелок,чтобы показать все возможные варианты<br>
        взаимодействия. И это - не еффективная коммуникация,где одно и тоже можно понять по-<br>
        разному при этом потратив какое-то время на пояснение чем шестиугольник отличается<br>
        от круга.
    </p>
    <h2>А что есть?</h2>
    <p>
        Осознав основные проблемы я первым делом начал искать готовые варианты. Вот несколько из них:
    </p>
    <p>
        <ul>
            <li>Диаграмма классов - иногда бывает удобной для анализа уже существующего кода, но<br>
            не применима для изначального проектирования,где мы оперируем более верхне<br>
            уровневым обьектам.</li>
        </ul>
    </p>
    <p>
        <ul>
            <li>C4model - уже ближе к теме и предлагает 4 уровня детализации схемы программного<br>
            обеспечения. Но часто из всех 4-х уровней подходит 3-й,когда мы планируем новый<br>
            сервис, а на 3-м уровне стандартов описания немного. Отлично подходит для верхнего<br>
            уровня описания системы, но при детализации на компоненты не имеет детальных<br>
            стандартов. </li>
        </ul>
    </p>
    Потому что после нескольких эспериментов, я решил подготовить простую нотацию,
    которая<br> позволит описать архитектуру приложений на том уровне, чтобы вы могли:
    <p>
        <ul>
            <li>Разбить создание его на задачи.</li>
            <li>Проверить корректность деления на модули,чтобы сократить их связанность.</li>
            <li>Упростить коммуникацию в команде при обсуждении деталей проектирования<br>
                приложения </li>
            <li>Использовать её для документирования архитектуры как монолита,так и<br>
            микросервисов.</li>
        </ul>
    </p>
    <h2>Требования к нотации</h2>
    <p>
        Перед тем, как переходить к описанию предлагаемой нотации следует сформулировать<br>
        требования, которым она должна удовлетворять:
    </p>
    <ul>
        <li>она должна на верхнем уровне описывать отделимые части системы,которые далее я<br> буду называть "компоненты"</li>
        <li>Связи между ними должны описать зависимости и поток вызовов,но не быть слишком<br>усложнены. По связям должно быть сразу понятно наличие архитектурных ошибок.</li>
        <li>Схема должна подходить как для описания монолитного приложения,так и<br>микросервисной архитектору</li>
        <li>Фокус должен быть на описании нашей архитектуры, максимально абстрагировавшись<br>от внешних систем. </li>
    </ul>
    <p>
        Ниже будет написано моё видение такой нотации с учётом опыта тестирования её вместе с<br>командой. На практике она позволила в кратчайшие сроки обсуждать изменения в<br>архитектуре или планировать полноценные новые сервисы и приложения.
    </p>
    <h2>Компоненты</h2>
    <p>
        Стоит начать рассмотрение именно с компонент,так как они являются строительными<br>блоками всей нашей диаграммы. 
        Это изолированный с точки зрения логики кусок кода,<br>который может в реальности представлять собой класс или отдельный файл. 
    </p>
    <p>
        Это может быть:
    </p>
    <ul>
        <li>Контроллер, которые обрабатывает входящие запросы.</li><br>
        <li>Сервис отвечающий за бизнес логику работы с платежами.</li><br>
        <li>Репозиторий,взаимодействующий с базой данных.</li><br>
        <li>Обработчик event событий при использовании event soursing.</li><br>
        <li>Бизнес entity пользователя,содержащие поля для него и медоты работы.</li><br>
    </ul>
    <p>
        Фактически всё, что вы можете выделить в виде класса с инкапсулированной логикой - это<br>компонент.
    </p>
    <p>
        Для того чтобы максимально плоно описать компонент можно указать слудующие<br>параметры:
    </p>
    <ul>
        <li>Имя - название компонента, отражающие его суть или даже название класса</li>
        <li>Тип - чтобы понять что это контроллер или репозиторий</li>
        <li>Пояснение - если требует дополнительные описание.</li>
    </ul>
    <p>
        Примеры:
    </p>
    <img src="./images/image2.png" alt ="" width="500px" />
    
</body>
</html>
